"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const upath_1 = __importDefault(require("upath"));
const shared_1 = require("../shared");
const utils_1 = require("../shared/utils");
// From: https://github.com/vercel/next.js/blob/canary/packages/next/next-server/lib/constants.ts.
const PHASE_PRODUCTION_BUILD = "phase-production-build";
const PHASE_DEVELOPMENT_SERVER = "phase-development-server";
const buildPhase = [PHASE_DEVELOPMENT_SERVER, PHASE_PRODUCTION_BUILD];
async function initPlasmicLoader(pluginOptions) {
    const defaultDir = pluginOptions.dir || process.cwd();
    const defaultOptions = {
        watch: process.env.NODE_ENV === "development",
        initArgs: {
            platform: "nextjs",
            "pages-dir": "./pages",
            "images-public-dir": "../../../public",
            "src-dir": "./components",
        },
        dir: defaultDir,
        plasmicDir: upath_1.default.join(defaultDir, ".next", ".plasmic"),
        pageDir: upath_1.default.join(defaultDir, "pages"),
    };
    return shared_1.generateEntrypoint({
        ...defaultOptions,
        ...pluginOptions,
    });
}
/*
 * Next does not support any asynchronous workflow for plugins. What we're doing here
 * is running PlasmicLoader in a promise and registering an ad-hoc Webpack plugin that
 * hooks into Webpack's "beforeCompile" hook (from where we can add async code).
 *
 * Next also runs Webpack twice (one for the server and another for the client) where
 * both runs are asynchronous. What we do is saving the PlasmicLoader promise as a
 * module-scoped variable and hook to it from both runs.
 */
let initPlasmicPromise;
module.exports = (pluginOptions) => {
    return (nextConfig = {}) => {
        return function (phase) {
            if (!buildPhase.includes(phase)) {
                return nextConfig;
            }
            if (!initPlasmicPromise) {
                initPlasmicPromise = initPlasmicLoader({
                    ...pluginOptions,
                    watch: pluginOptions.watch !== undefined
                        ? pluginOptions.watch
                        : phase === PHASE_DEVELOPMENT_SERVER,
                });
            }
            return Object.assign({}, nextConfig, {
                webpackDevMiddleware: (config) => {
                    // Ignore .next, but don't ignore .next/.plasmic.
                    config.watchOptions.ignored = config.watchOptions.ignored.filter((ignore) => !ignore.toString().includes(".next"));
                    config.watchOptions.ignored.push(/.next\/(?!.plasmic)/);
                    return config;
                },
                webpack(config, options) {
                    config.plugins.push({
                        __plugin: "PlasmicLoaderPlugin",
                        apply(compiler) {
                            compiler.hooks.beforeCompile.tapAsync("PlasmicLoaderPlugin", (params, callback) => {
                                utils_1.ensure(initPlasmicPromise).then(callback);
                            });
                        },
                    });
                    if (typeof nextConfig.webpack === "function") {
                        return nextConfig.webpack(config, options);
                    }
                    return config;
                },
            });
        };
    };
};
