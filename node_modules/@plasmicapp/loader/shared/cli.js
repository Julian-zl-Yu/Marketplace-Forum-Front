"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearStalePages = exports.syncProject = exports.readConfig = exports.checkAuth = exports.tryInitializePlasmicDir = void 0;
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = __importDefault(require("child_process"));
const promises_1 = __importDefault(require("fs/promises"));
const upath_1 = __importDefault(require("upath"));
const util_1 = __importDefault(require("util"));
const exec = util_1.default.promisify(child_process_1.default.exec);
async function execOrFail(dir, command, message) {
    try {
        await exec(command, {
            cwd: dir,
            stdio: "inherit",
            env: { ...process.env, PLASMIC_LOADER: 1 },
        });
    }
    catch (e) {
        console.error(e);
        console.error(chalk_1.default.bold(chalk_1.default.redBright("Plasmic error:")), message);
        process.exit(1);
    }
}
function objToExecArgs(obj) {
    return Object.entries(obj)
        .map(([param, value]) => `--${param}=${Array.isArray(value) ? value.join(",") : value}`)
        .join(" ");
}
async function tryInitializePlasmicDir(dir, plasmicDir, initArgs) {
    const plasmicExecPath = upath_1.default.join(dir, "node_modules", ".bin", "plasmic");
    const configPath = upath_1.default.join(plasmicDir, "plasmic.json");
    try {
        await promises_1.default.access(configPath);
        console.log(".plasmic directory detected, skipping init.");
        return;
    }
    catch { }
    await promises_1.default.mkdir(plasmicDir, { recursive: true });
    await execOrFail(plasmicDir, `${plasmicExecPath} init --yes=true ${objToExecArgs(initArgs)}`, "Unable to initialize Plasmic. Please check the above error and try again.");
}
exports.tryInitializePlasmicDir = tryInitializePlasmicDir;
function checkAuth(dir, execPath) {
    return execOrFail(dir, `${execPath} auth --check`, "Unable to authenticate Plasmic. Please run `plasmic auth` or check your ~/.plasmic.auth file, and try again.");
}
exports.checkAuth = checkAuth;
async function readConfig(dir) {
    const configPath = upath_1.default.join(dir, "plasmic.json");
    const configData = await promises_1.default.readFile(configPath);
    return JSON.parse(configData.toString());
}
exports.readConfig = readConfig;
async function syncProject(dir, pageDir, execPath, projects) {
    const oldConfig = await readConfig(dir);
    await execOrFail(dir, `${execPath} sync --yes --metadata source=loader --projects ${projects.join(" ")}`, "Unable to sync Plasmic project. Please check the above error and try again.");
    return clearStalePages(dir, pageDir, oldConfig);
}
exports.syncProject = syncProject;
async function clearStalePages(dir, pageDir, oldConfig) {
    const seen = {};
    const stalePaths = [];
    const newConfig = await readConfig(dir);
    for (const project of newConfig.projects) {
        for (const component of project.components) {
            if (component.componentType !== "page") {
                continue;
            }
            seen[component.id] = true;
        }
    }
    for (const project of oldConfig.projects) {
        for (const component of project.components) {
            if (component.componentType !== "page") {
                continue;
            }
            if (!seen[component.id]) {
                const [_, componentPath] = component.importSpec.modulePath.split(/pages/);
                stalePaths.push(upath_1.default.join(pageDir, componentPath));
                stalePaths.push(upath_1.default.join(dir, "pages", componentPath));
            }
        }
    }
    return Promise.all(stalePaths.map((filePath) => promises_1.default.unlink(filePath)));
}
exports.clearStalePages = clearStalePages;
