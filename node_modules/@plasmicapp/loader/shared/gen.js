"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAll = void 0;
const dot_1 = __importDefault(require("dot"));
const promises_1 = __importDefault(require("fs/promises"));
const upath_1 = __importDefault(require("upath"));
dot_1.default.templateSettings.strip = false;
function writeFile(filePath, content) {
    return promises_1.default
        .mkdir(upath_1.default.dirname(filePath), { recursive: true })
        .then(() => promises_1.default.writeFile(filePath, content));
}
async function generateAll(opts) {
    const configPath = upath_1.default.join(opts.dir, "plasmic.json");
    const configData = await promises_1.default.readFile(configPath);
    const config = JSON.parse(configData.toString());
    const templatePath = upath_1.default.join(__dirname, "../", "templates");
    const templates = dot_1.default.process({ path: templatePath });
    await Promise.all([
        generatePlasmicLoader(opts.dir, config, templates),
        opts.ignorePages
            ? Promise.resolve()
            : generatePageComponents(opts.pageDir, config, templates),
    ]);
}
exports.generateAll = generateAll;
async function generatePageComponents(dir, config, templates) {
    const componentData = [];
    for (const project of config.projects) {
        for (const component of project.components) {
            if (component.componentType !== "page") {
                continue;
            }
            const [_, componentPath] = component.importSpec.modulePath.split(/pages/);
            componentData.push({
                name: component.name,
                projectId: project.projectId,
                path: upath_1.default.join(dir, componentPath),
            });
        }
    }
    await Promise.all(componentData.map((data) => writeFile(data.path, templates.PlasmicPage({
        name: data.name,
        projectId: data.projectId,
    }))));
}
function generatePlasmicLoader(dir, config, templates) {
    var _a;
    const entrypointPath = upath_1.default.join(__dirname, "../", "PlasmicLoader.jsx");
    const componentData = [];
    const componentDataKeyedByName = {};
    for (const project of config.projects) {
        for (const component of project.components) {
            const data = {
                name: component.name,
                projectId: project.projectId,
                path: upath_1.default.join(dir, config.srcDir, component.renderModuleFilePath),
            };
            if (!componentDataKeyedByName[data.name]) {
                componentDataKeyedByName[data.name] = [];
            }
            componentData.push(data);
            componentDataKeyedByName[data.name].push(data);
        }
    }
    const providerData = [];
    const providersKeyedByName = {};
    for (const provider of ((_a = config.globalVariants) === null || _a === void 0 ? void 0 : _a.variantGroups) || []) {
        const data = {
            name: provider.name,
            projectId: provider.projectId,
            path: upath_1.default.join(dir, config.srcDir, provider.contextFilePath),
            providerName: provider.name === "Screen" ? "ScreenVariantProvider" : "",
        };
        if (!providersKeyedByName[data.name]) {
            providersKeyedByName[data.name] = [];
        }
        providerData.push(data);
        providersKeyedByName[data.name].push(data);
    }
    return writeFile(entrypointPath, templates.PlasmicLoader({
        componentData,
        componentsWithOneProject: Object.values(componentDataKeyedByName)
            .filter((components) => components.length === 1)
            .flat(),
        componentMap: Object.entries(componentDataKeyedByName).map(([name, projects]) => ({ name, projects })),
        providerData,
        providersWithOneProject: Object.values(providersKeyedByName)
            .filter((providers) => providers.length === 1)
            .flat(),
        providerMap: Object.entries(providersKeyedByName).map(([name, projects]) => ({ name, projects })),
    }));
}
